from .district import DistrictAgent

import geopandas as gpd
import pandas as pd

def redistrict(model, new_districts):
    '''
    Update the boundaries of the districts based on new_districts GeoDataFrame.

    new_districts: GeoDataFrame of the new districts
    '''
    for district in model.USHouseDistricts:
        new_district = new_districts[new_districts['district'] == district.unique_id]
        if not new_district.empty:
            new_geometry = new_district['geometry'].iloc[0]
            district.update_district_geometry(new_geometry)
            district.update_district_data()
            district.update_district_color()

def process_plans(model, unprocessed_plans):
    '''
    Process the plans by melting, dissolving, and converting to geopandas dataframe.

    unprocessed_plans: GeoDataFrame of the unprocessed plans generated by GerryChain
    '''
    # Melt the plans
    processed_plans = unprocessed_plans.melt(id_vars='geometry', var_name='plan', value_vars=[f'plan_{i}' for i in range(model.n_proposed_maps)], value_name='district')
    # Remove 'plan_' prefix from plan column
    processed_plans['plan'] = processed_plans['plan'].str.replace('plan_', '')
    # Dissolve by plan and district
    processed_plans = processed_plans.dissolve(by=['plan', 'district']).reset_index()
    # Convert district to string
    processed_plans['district'] = processed_plans['district'].astype(str)
    # Convert crs to model crs
    processed_plans = processed_plans.to_crs(model.space.crs)

    return processed_plans

def evaluate_plans(model, ensemble):
    '''
    Evaluate the ensemble of plans by all possible metrics.

    ensemble: GeoDataFrame of all the potential plans generated for the current redistricting step
    '''
    results = {}
    for i in range(-1, model.n_proposed_maps):
        # Extract the districts for the plan
        new_districts = ensemble[ensemble['plan'] == str(i)]
        # Update the boundaries of the districts
        redistrict(model, new_districts)
        # Update the statistics of the model
        model.datacollector.collect(model) # TODO: Check if this is necessary
        # Save the results
        results[f'{i}'] = {
            'unhappy': model.happy,
            'happy': model.unhappy,
            'red_congressional_seats': model.red_congressional_seats,
            'blue_congressional_seats': model.blue_congressional_seats,
            'tied_congressional_seats': model.tied_congressional_seats,
            'efficiency_gap': model.efficiency_gap,
            'mean_median': model.mean_median,
            'declination': model.declination
        }
    print('\nresults:\n', results)
    return results

def generate_ensemble(model):
    ''' 
    Generate ensemble of plans with GerryChain, process them, and add current district map. 
    '''
    # Generate ensemble of plans
    for i, partition in enumerate(model.recom_chain):
        model.precincts['plan_{}'.format(i)] = [partition.assignment[n] for n in model.graph.nodes]

    # Transform the plans
    unprocessed_plans = model.precincts[[f'plan_{i}' for i in range(model.n_proposed_maps)] + ['geometry']]

    # Process the plans
    processed_plans = process_plans(model, unprocessed_plans)

    # Add current plan to the processed plans
    for district in model.USHouseDistricts:
        # Convert district to GeoDataFrame
        district_gdf = gpd.GeoDataFrame({'plan': '-1', 'district': district.unique_id, 'geometry': [district.geometry]}, crs=model.space.crs)
        processed_plans = pd.concat([processed_plans, district_gdf], ignore_index=True)

    # TODO: Save plans to file for each step
    # print('processed plans:\n', processed_plans)
    return processed_plans

def gerrymander(model):
    '''
    Performs the gerrymandering phenomon.

    Steps:
        1. generates ensemble of plans
        2. evaluates ensemble
        3. selects map from ensemble (+current map) that maximizes the parisan gain by party in controll of redistricting
            (in case of tie, the most neutral map is selected)
    '''
    # Generate/save ensemble of plans
    ensemble = generate_ensemble(model)

    # Evalaute the plans
    eval_results = evaluate_plans(model, ensemble)

    # Find the plan that maximizes the number of districts favoring the party in control
    if model.control == 'Republican':
        # Select plan with most red districts
        best_plan = max(eval_results, key=lambda x: eval_results[x]['red_congressional_seats'])
        best_plan_districts = ensemble[ensemble['plan'] == best_plan]
        redistrict(model, best_plan_districts)
        
        if model.console:
            print('\nBest Republican plan:', best_plan)
            print('Best Republican plan districts:\n', best_plan_districts)
            print('Republican state, maximizing red districts')
            
    elif model.control == 'Democratic':
        # Select plan that most blue districts
        best_plan = max(eval_results, key=lambda x: eval_results[x]['blue_congressional_seats'])
        best_plan_districts = ensemble[ensemble['plan'] == best_plan]
        redistrict(model, best_plan_districts)

        if model.console:
            print('\nBest Democratic plan:', best_plan)
            print('Best Democratic plan districts:\n', best_plan_districts)
            print('Democrart state, maximizing blue districts')

    # Or, in case of a tie, select the plan that minimizes efficiency gap
    elif model.control == 'Tied':
        # Select plan with efficiency gap closest to 0 (fairness)
        best_plan = min(eval_results, key=lambda x: abs(eval_results[x]['efficiency_gap']))
        best_plan_districts = ensemble[ensemble['plan'] == best_plan]
        redistrict(model, best_plan_districts)

        if model.console:
            print('\nBest plan:', best_plan)
            print('Best plan districts:\n', best_plan_districts)
            print('Tied state, minimizing efficiency gap')

    # Keep track controlling party before population shift
    model.datacollector.collect(model) # TODO: Check if this is necessary
    model.control = model.projected_winner